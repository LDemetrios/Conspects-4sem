#import "/sources/header.typ": *

#show: general-style

#setup-exec("gpu.typexec", it => read(it))

= Программирование на видеокартах

== Начало

=== Как всё это компилировать

==== Хост-код

`.h` файлы для C/C++ есть на официальном сайте, правда, там есть
задепрекейченные полезные функции. Придётся задефайнить версию. Достаточно
хедера `<CL/cl.h>`. Можно --- `<CL/opencl.h>`

Чтобы слиноваться, надо где-то взять либы. Под линуксом --- некий магический
package. Под виндоусом --- откуда-то взять. На официальном сайте Кроноса есть.
Обратите внимание на битность!

==== Девайс-код

Само разберётся. Обычно.

==== Запуск

В пределах конспекта код запускается с помощью `cmake`:

#let cl-cmake = read("aux/gpu-cmake.txt")

#shraw(cl-cmake, lang: "cmake")

#let cpp-prelude = state("cpp-prelude", "")

Инклюдим некоторое количество штук:

#let append-prelude(code, and-show: true) = {
  cpp-prelude.update(it => it + "\n\n" + to-code(code))

  if and-show {
    shraw(code, lang: "cpp")
  }
}

#append-prelude(```cppprelude
#include <iostream>
#include <set>
#include <vector>
#include <CL/cl.h>
```)

Нам часто придётся выводить векторы, поэтому

#append-prelude(```cppprelude
template <class T>
std::ostream& operator<<(std::ostream& out, std::vector<T>& v) {
    out << '[';
    for (size_t i = 0; i < v.size(); i++) {
        if (i != 0) out << ' ';
        out << v[i];
    }
    out << ']';
    return out;
}
```)

И, поскольку я не плюсовик, напишу так и вы будете страдать:

#append-prelude(```cppprelude
#define println(x) do { std::cout << x << std::endl; } while(0)
```)

#let cpp-code = state("cpp-code", "")

#let parse-cmake-result(result) = {
  if type(result) != array or result.len() != 3 or result.map(it => type(it)).any(it => it != dictionary) {
    text(fill: blue, `Evaluation results are invalid`)
  } else if result.at(0).at("returnCode", default: -1) != 0 {
    text(fill: red, `Error preparing CMake`)
    [\ ]
    text(fill: red, raw(result.at(0).at("error", default: "")))
  } else if result.at(1).at("returnCode", default: -1) != 0 {
    text(fill: red, `Compilation error`)
    [\ ]
    text(fill: red, raw(result.at(1).at("error", default: "")))
  } else {
    raw(result.at(2).at("output", default: "").split("//////////\n").at(-1, default:""))
    if (result.at(1).at("returnCode", default: -1) > 0) {
      [\ ]
      raw("Exited with " + result.at(1).returnCode)
    }
  }
}

#let execcpp() = {
  cpp-prelude.display(prelude => {
    // raw(prelude + "int main() {\n" + body.text + "\n}\n")
    // [\ \ ]
    cpp-code.display(body =>
    exec((
      "main.cpp": prelude + "\n\nint main() {\n" + body + "\n}\n",
      "CMakeLists.txt": cl-cmake,
    ), eval(read("aux/cmake-build-command.txt")), (result) => {
      tablex(
        columns: (2em, auto),
        auto-vlines: false,
        auto-hlines: false,
        stroke: foreground,
        [],
        vlinex(),
        pad(.25em, left: .5em, parse-cmake-result(result)),
      )
    }))
  })
}

#show raw.where(lang: "excpp") : (body) => {
  cpp-code.update(it => body.text)

  pad(right:-100em, text(size: 1.25em, shraw(body, lang: "cpp")))

  execcpp()
}

#show raw.where(lang: "excppapp") : (body) => {
  cpp-code.update(it => it + ";\n println(\"//////////\");\n " + body.text)

  pad(right:-100em, text(size: 1.25em, shraw(body, lang: "cpp")))

  execcpp()
}

Пытаемся запустить:

```excpp
std::vector v({1, 2, 3});
println(v);
```

Работает.

=== API

Большинство функций возвращают код ошибки (как обычно, 0 --- успешно, не 0 ---
не успешно). Надо проверять! Во всяком случае, в дебаге, в учебных целях.
Написать макрос? Какой ужас.

Это за исключением функций типа `create`, которые возвращают то, что они
`create`. Тогда код ошибки, если нужен, по ссылке, передаваемой в аргумент...
Такой типичный С.

==== `clGetPlatformIDs`
--- API для получения списка доступных платформ. Принимает... Указатель, размер,
и указатель на размер... Буффер, размер буффера, и то, куда записывать, сколько.

Понятное дело, память она не выделяет. Так как надо, чтобы освобождал тот, кто
выделил. Такой типичный С...

Так, а какого размера выделять буффер? Для этого есть специальный вариант
вызова: `(nullptr, 0, &x)` --- тогда в `x` нам запишут то, сколько на самом деле
вариантов. Идейно. Такой принцип применяется здесь во всемх вызовах.

Правда, в отличие от типичного С, если буфера мало, то это не ошибка "буфера
мало", а нам запишут, сколько есть места.

Можно сказать, "возвращает" эта функция список id платформ, где можно запустить
opencl.

```excpp
uint32_t s;
clGetPlatformIDs(0, nullptr, &s);
std::vector<cl_platform_id> platforms(s);
clGetPlatformIDs(s, platforms.data(), &s);
println(platforms);
```

Результат не вполне содержательный --- `cl_platform_id` это просто указатель на
не очень понятно что. Но нам это и не надо --- это всего лишь идентификатор,
который умеют понимать другие функции апи.

==== `clGetPlatformInfo`
--- Получаем информацию о конкретной платформе. Сюда передаётся `platformID`, полученный на предыдущем этапе, и константа, обозначающая, какую информацию мы хотим. Остальное --- как раньше.

```excppapp
for (auto platform : platforms) {
    println(platform);
    size_t pl_name_length;
    clGetPlatformInfo(platform, CL_PLATFORM_NAME, 0, nullptr, &pl_name_length);
    std::vector<char> pl_name(pl_name_length);
    clGetPlatformInfo(platform, CL_PLATFORM_NAME, pl_name_length, pl_name.data(),
                      &pl_name_length);
    std::string str(pl_name.begin(), pl_name.end());
    println(str);
}
```

Здесь можно запросить разную информацию. Но сначала давайте научимся в нормальном виде запрашивать информацию... А то это же ужас. Напишем хоть какую-то обёртку (да простят меня боги плюсов за количество `auto` в этом коде). 

#append-prelude(```
template <class SizeT, class T>
std::vector<T> request(auto func, auto... args) {
    SizeT size;
    func(args..., 0, nullptr, &size);
    std::vector<T> result(size);
    func(args..., size, result.data(), &size);
    return result;
}
```)

Теперь это будет хотя бы относительно прилично выглядеть

```excpp
std::vector<cl_platform_id> platforms =
            request<uint32_t, cl_platform_id>(&clGetPlatformIDs);
println(platforms);
println("");

for (auto platform : platforms) {
    println(platform);
    std::vector<char> name = request<size_t, char>(
          &clGetPlatformInfo, platform, CL_PLATFORM_NAME
    );
    std::string str(name.begin(), name.end());
    println(str);
}
```

#TODO("show rule 'типичный С'")
#TODO("getDeviceIDs")

== Делаем что-то полезное

Допустим, мы выбрали девайс, который нам нравится, с которым мы хотим работать.

Теперь нам нужно создать контекст.

- `clCreateContext`

Контекст --- это своего рода `globalThis` от мира OpenCL. Он инкапсулирует в
себе всё, что мы хотим из хост-кода делать с девайс-кодом.

Теперь нужно в этом контексте создать тот код, который мы будем запускать в этом
контексте:

- `clCreateProgramWithSource`

  "Принимает" массив указателей на source.

  #TODO("Наебаться на сто дурных")

  Обычно мы хотим не извращаться с C-style строчками, а иметь отдельный файл с
  исходным кодом (обычно расширение `.cl`). То есть, надо открыть файл, прочитать
  и скормить (компиляция девайс-кода будет уже в рантайме). Предлагается
  использовать обычные C'шные функции fread и прочее. Открыть в `binary`, `seek`
  до конца и так далее. Типичный С...

  Эта функция не делает ничего особенного. Если мы тут зафейлились, мы где-то
  конкретно налажали --- передали кривой буфер или ещё что-нибудь. Ошибки внутри
  девайс-кода будут обнаруживаться уже потом.

- `clBuildProgram`

  Вот это уже серьёзно: компиляция нашего исходника. Передаём сюда `id` нашего
  `program`'a, который мы по'create'или, и девайс, под который надо скомпилиться.
  Или передать null, и тогда будет скомпилированно под все девайсы, привязанные к
  контексту.

  Компиляция может занимать продолжительное время! Имеет смысл локально
  закэшировать. Но так как результат сильно зависит от драйверов, девайсов,
  версий, погоды, фазы луны; распространять прекомпилированную версию не имеет
  смысла.

  Если в девайс-коде есть какая-нибудь синтаксическая (или ещё что-нибудь) ошибка,
  то она вылезет здесь. Обязательно проверять результат здесь! Можно сделать
  `clGetBuildInfo`, чтобы получить билд-лог (своего рода compilation error), ему
  нужно давать честный `id` девайса.

  build-options --- не должен быть null! Некоторые платформы могут его не
  пережить. Передайте пустую строчку. Или, лучше, используйте по назначению!
  Например, можно с помощью `-D` передавать дефайнами переменными.

=== Наконец, девайс-код

```
kernel void add(global const int *a, global const int *b, global int *c) {
  *c = *a + *b;
}
```

Здесь немного нового по сравнению с С.

- `kernel` означает, что это точка входа в программу. Их может быть несколько ---
  это не совсем то же, что `main`.

- `clCreateKernel` --- создаёт идентификатор, через который мы сможем вызывать
  `kernel`. Передаём туда имя.

Теперь мы хотим передать ему аргументы и запустить его! Проблемы? Э-э-э.........
Указатели на память, что вы думаете, сработает? Ха. Где память? На девайсе. Мы
её выделили? Нет. Очень жаль. Давайте выделять...

=== Here we go again

- Выделяем память на девайсе: `clCreateBuffer`. Нам надо только передать размер
  буфера, и то, как мы хотим к нему обращаться из кернела (read only, write only,
  read-write). В данном случае, мы хотим три буфера: под `a` и под `b` ---
  read-only, под `c` --- write-only. Ну, мы можем оба подписать read-write, но
  лучше так --- так что-нибудь оптимизировать (не надо про протокол когерентности,
  кэши, всё остальное думать).

  Понятно, что доступ распространяется только на кернел, с хоста-то мы и так
  записать/прочитать сможем.

  `clCreateBuffer` возвращает `cl_mem`, это своего рода указатель, но не
  указатель. Это хендл, арифметику с ним делать нельзя.

- А мы написали `int`... а что это? Понятное дело, что `int` на девайсе и `int` на
  хосте могут отличаться. Ну так для этого может быть `cl_int`. На самом деле, они
  даже фиксированы, не зависят от девайса. Так что это всегда 32 бита. Лучше, чем
  в С! А вот `size_t` девайса мы не знаем. Точнее, можем спросить, но это будет
  уже в рантайме и у конкретного девайса. Так что кернелам просто запрещено
  принимать `size_t`.

- Наконец, можем накормить кернел аргументами: `clSetKernelArg`, указываем туда
  идентификатор кернела, номер аргумента, значение аргумента (оно --- как адрес +
  количество байтов).

- В наших буферах лежит какой-то мусор, надо его наполнить.
  `clEnqueueWriteBuffer`. Чувствуется в названии подвох.

- `clCreateCommandQueue` --- очередь команд, чего мы хотим. Принимает контекст и
  девайс. А ещё принимает _флажки_. Один из них полезный --- profiling info (или
  как-то так), причём почти ничего не стоит. Рассказывает, сколько времени уходит
  на процессы. Второй --- `out of order executionary order`. Не влезай, убьёт.

- `clEnqueueWriteBuffer`, да. Принимает cl_mem, указатель наш (откуда брать
  данные), флажок `blocking write` (позже). Про блокирующее чтение. Мы ставим _задание на постановку в очередь_.
  Если мы не поставим флажок, то оно вернётся мгновенно! И ничего не дождётся.
  Имеет смысл делать передачу данных *на* девайс не блокирующей, а *с* девайса ---
  блокирующей. Очередь ленивая, не будет ничего исполнять, пока мы не пнём её. Ну,
  или можно пнуть через "подождать выполнения всех функций". Или спросить "#strike[а не в омах ли измеряется сопротивление] а
  не закончилось ли исполнение".

- Спойлер: В конце захотим `clEnqueueReadBuffer`.

- `clEnqueueNDRangeKernel` --- урааа! Запуск кернела. Передаём туда, очевидно,
  очередь и кернел. Принимает также dimensions (who? пока передаём 1); global work
  size, причём через указатель (пока тоже 1); local work size --- смело кормим
  null'ами, так же поступаем с event'ами.

- Наконец, делаем `clEnqueueReadBuffer`, и читаем нашу замечательную сумму двух
  чисел. Будем на это, во всяком случае, надеяться.

- Замечание к окончанию: всё, что мы `create`, хорошо бы потом `release`. А то
  может быть грустно.
- А если что-нибудь криво работает на девайсе... Ну, упадёт видео-драйвер. Винда
  его обычно поднимает через пару секунд, остальные --- ... поэкспериментируйте!

#close-exec()
